<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mapa Mental do Bairro ‚Äî Prot√≥tipo</title>
<style>
:root{
--bg:#0f1724; --card:#0b1220; --accent:#2dd4bf; --muted:#94a3b8; --good:#16a34a;
--bad:#ef4444;
}
body{margin:0;font-family:Inter,Segoe
UI,Roboto,Arial;background:linear-gradient(180deg,#071126 0%, #07182a
100%);color:#e6eef6}
header{padding:18px 22px;display:flex;align-items:center;gap:16px}
h1{margin:0;font-size:20px}
.container{display:flex;gap:18px;padding:14px;flex-wrap:wrap}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02),
rgba(255,255,255,0.01));border-radius:10px;padding:14px;box-shadow:0 6px 18px
rgba(2,6,23,0.6)}
.left{flex:1;min-width:320px;max-width:720px}
.right{width:360px;min-width:260px}
.map{background:#051028;border-radius:8px;padding:8px}
svg{width:100%;height:480px;background:linear-gradient(180deg, rgba(255,255,255,0.01),
transparent);border-radius:6px}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
select,input[type=range]{padding:8px;border-radius:8px;border:none;background:rgba(255,255,
255,0.03);color:inherit}
button{padding:10px
12px;border-radius:8px;border:none;background:var(--accent);color:#022;cursor:pointer}
.question{margin:10px 0;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02)}
.choices{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.choice{padding:10px;border-radius:8px;background:rgba(255,255,255,0.015);cursor:pointer}
.choice:hover{outline:1px solid rgba(255,255,255,0.03)}
.stats{margin-top:12px;font-size:13px;color:var(--muted)}
.score{font-size:20px;color:var(--accent);font-weight:700}
.small{font-size:12px;color:var(--muted)}
.highlight-good{stroke:var(--good);stroke-width:4;opacity:1}
.highlight-bad{stroke:var(--bad);stroke-width:4;opacity:1}
.street-label{font-size:11px;fill:#bfeaf0}
.connector{stroke:#fff3;border-dasharray:4}
.leaderboard{margin-top:12px}
.leaderboard li{padding:6px
8px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px}
footer{padding:18px;color:var(--muted);font-size:13px}
.btn-ghost{background:transparent;border:1px solid
rgba(255,255,255,0.04);color:var(--muted)}

.badge{display:inline-block;padding:6px
8px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:12px}
</style>
</head>
<body>
<header>
<h1>MAPA MENTAL DO BAIRRO ‚Äî Prot√≥tipo Jog√°vel</h1>
<div class="small">Memorize as ruas enquanto se diverte üéØ</div>
</header>
<div class="container">
<div class="left panel">
<div class="controls">
<label>
Bairro:
<select id="bairroSelect"></select>
</label>
<label>
Dificuldade:
<select id="difficulty">
<option value="easy">F√°cil</option>
<option value="medium">M√©dio</option>
<option value="hard">Dif√≠cil</option>
<option value="insane">Insano</option>
</select>
</label>
<button id="startBtn">Iniciar</button>
<button id="nextBtn" class="btn-ghost" style="display:none">Pr√≥xima</button>
<div style="margin-left:auto" class="small">Pontos: <span id="score">0</span> ‚Ä¢ Combo:
<span id="combo">x1</span></div>
</div>
<div class="map panel">
<svg id="mapSvg" viewBox="0 0 1000 700" preserveAspectRatio="xMidYMid meet">
<defs>
<marker id="arrow" viewBox="0 0 10 10" refX="6" refY="5" markerWidth="6"
markerHeight="6" orient="auto">
<path d="M 0 0 L 10 5 L 0 10 z" fill="#fff" opacity="0.7" />
</marker>
</defs>
<!-- Streets will be drawn here -->
</svg>
</div>
<div class="question panel" id="questionPanel" style="display:none">
<div id="questionText" style="font-weight:600"></div>
<div class="choices" id="choices"></div>
<div class="stats">

<div>Tempo restante: <span id="timeLeft">--</span>s ‚Ä¢ Respostas certas seguidas: <span
id="streak">0</span></div>
<div class="small">Erros por rua: <span id="errorList">nenhum</span></div>
</div>
</div>
<div class="panel" style="margin-top:10px">
<div style="display:flex;gap:12px;align-items:center">
<div class="score">Score: <span id="scoreLarge">0</span></div>
<div class="small">Mastery do bairro: <span id="masteryPct">0%</span></div>
<div style="margin-left:auto"><button id="exportStats" class="btn-ghost">Exportar
stats</button></div>
</div>
<div class="small" style="margin-top:8px">Progresso: <progress id="progress" value="0"
max="100" style="width:100%"></progress></div>
</div>
</div>
<div class="right panel">
<div style="display:flex;justify-content:space-between;align-items:center">
<div><strong>Rankings (local)</strong></div>
<div><span class="badge" id="badgeMode">Modo: Quiz</span></div>
</div>
<div class="leaderboard panel" style="margin-top:10px">
<strong>Leaderboard</strong>
<ol id="leaderboardList"></ol>
<div style="display:flex;gap:8px;margin-top:8px">
<input id="playerName" placeholder="Seu nome"
style="flex:1;padding:8px;border-radius:8px;border:none;background:rgba(255,255,255,0.02);co
lor:inherit">
<button id="saveScore">Salvar</button>
</div>
</div>
<div style="margin-top:12px" class="panel">
<strong>Estat√≠sticas</strong>
<div class="small" style="margin-top:8px">
Total jogadas: <span id="plays">0</span><br>
Acertos: <span id="totalCorrect">0</span> ‚Ä¢ Erros: <span id="totalWrong">0</span>
</div>
</div>
<div style="margin-top:12px" class="panel">
<strong>Modo Morador Pro</strong>
<div class="small" style="margin-top:8px">Desbloqueia ao dominar 80% do bairro.
<br>Quando desbloqueado, desbloqueia miss√µes de entrega e trajetos.</div>

<button id="moradorProBtn" style="margin-top:8px" disabled>Ir para Morador Pro</button>
</div>
</div>
</div>
<footer>
Prot√≥tipo funcional ‚Äî personalize dataset de ruas no c√≥digo. Salve como
<code>index.html</code> e abra no navegador.
</footer>
<script>
/* -------------------------
Dados de exemplo (Jardim Damasceno)
Estrutura: ruas com coordenadas e rela√ß√µes
-------------------------*/
const bairros = {
"Jardim Damasceno": {
name: "Jardim Damasceno",
streets: [
{id:"Talha Mar", x:120, y:120, angle:0},
{id:"Grumix√°", x:160, y:140, angle:10},
{id:"Avante", x:220, y:120, angle:0},
{id:"Serra Dourada", x:280, y:180, angle:20},
{id:"Gasparino", x:100, y:220, angle:90},
{id:"Travessa Pedra Azul", x:190, y:200, angle:90},
{id:"Rua X", x:340, y:120, angle:0},
{id:"Rua Y", x:340, y:220, angle:0},
{id:"Rua Z", x:360, y:70, angle:0},
{id:"Rua ABC", x:60, y:80, angle:30}
],
// liga√ß√µes manualmente definidas (nomes)
links: [
["Talha Mar","Grumix√°"],
["Talha Mar","Rua ABC"],
["Grumix√°","Avante"],
["Avante","Rua X"],
["Gasparino","Travessa Pedra Azul"],
["Travessa Pedra Azul","Serra Dourada"],
["Serra Dourada","Avante"],
["Rua Y","Rua X"],
["Rua Z","Rua X"],
["Rua ABC","Talha Mar"]
],
parallels: [
["Talha Mar","Avante"],
["Rua X","Rua Y"]
],

// simple points of interest (not used heavily now)
pois: [
{name:"Pra√ßa Central", x:210, y:160},
{name:"Mercadinho", x:320, y:140}
]
}
};
/* -------------------------
Estado do jogo
-------------------------*/
let state = {
bairroName: Object.keys(bairros)[0],
data: null,
score: 0,
combo: 1,
streak: 0,
currentQuestion: null,
timeLeft: 15,
timer: null,
difficulty: 'easy',
stats: {
plays: 0, correct:0, wrong:0, wrongByStreet: {}
}
};
/* -------------------------
Helper: find street by id
-------------------------*/
function getStreet(id){
return state.data.streets.find(s=>s.id===id);
}
/* -------------------------
Build UI selects
-------------------------*/
function populateBairros(){
const sel = document.getElementById('bairroSelect');
sel.innerHTML = '';
for(const k in bairros){
const o = document.createElement('option'); o.value=k; o.textContent=k;
sel.appendChild(o);
}
sel.value = state.bairroName;
}
populateBairros();
/* -------------------------

Prepare dataset: attach adj list
-------------------------*/
function loadBairro(name){
const raw = JSON.parse(JSON.stringify(bairros[name])); // clone
raw.streets.forEach(s => { s.links = []; });
// build adjacency
raw.links.forEach(pair=>{
const a = raw.streets.find(s=>s.id===pair[0]);
const b = raw.streets.find(s=>s.id===pair[1]);
if(a && b){
a.links.push(b.id);
b.links.push(a.id);
}
});
state.data = raw;
updateMap();
updateStatsUI();
}
/* -------------------------
Draw map (SVG)
-------------------------*/
function updateMap(){
const svg = document.getElementById('mapSvg');
while(svg.firstChild) svg.removeChild(svg.firstChild);
// defs
const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
svg.appendChild(defs);
// background rectangle
const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width','1000');
bg.setAttribute('height','700');
bg.setAttribute('fill','transparent');
svg.appendChild(bg);
// draw links as lines
state.data.links.forEach(pair=>{
const a = getStreet(pair[0]); const b = getStreet(pair[1]);
if(!a||!b) return;
const line = document.createElementNS('http://www.w3.org/2000/svg','line');
line.setAttribute('x1', a.x); line.setAttribute('y1', a.y);
line.setAttribute('x2', b.x); line.setAttribute('y2', b.y);
line.setAttribute('stroke','rgba(255,255,255,0.08)');
line.setAttribute('stroke-width','4');
line.setAttribute('data-link', JSON.stringify([a.id,b.id]));
svg.appendChild(line);
});

// draw streets as short segments with label
state.data.streets.forEach(s=>{
const g = document.createElementNS('http://www.w3.org/2000/svg','g');
g.setAttribute('class','streetGroup');
g.setAttribute('data-street', s.id);
const len = 80;
const ang = s.angle * Math.PI/180;
const x2 = s.x + Math.cos(ang)*len;
const y2 = s.y + Math.sin(ang)*len;
const line = document.createElementNS('http://www.w3.org/2000/svg','line');
line.setAttribute('x1', s.x); line.setAttribute('y1', s.y);
line.setAttribute('x2', x2); line.setAttribute('y2', y2);
line.setAttribute('stroke','rgba(255,255,255,0.12)');
line.setAttribute('stroke-width','6');
line.setAttribute('stroke-linecap','round');
line.setAttribute('id','line-'+encodeURIComponent(s.id));
g.appendChild(line);
const text = document.createElementNS('http://www.w3.org/2000/svg','text');
text.setAttribute('x', s.x+6);
text.setAttribute('y', s.y-8);
text.setAttribute('class','street-label');
text.textContent = s.id;
g.appendChild(text);
svg.appendChild(g);
});
// POIs
state.data.pois.forEach(p=>{
const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
c.setAttribute('cx', p.x); c.setAttribute('cy', p.y); c.setAttribute('r',6);
c.setAttribute('fill','#ffd166'); svg.appendChild(c);
const t = document.createElementNS('http://www.w3.org/2000/svg','text');
t.setAttribute('x', p.x+10); t.setAttribute('y', p.y+4); t.setAttribute('class','street-label');
t.textContent = p.name; svg.appendChild(t);
});
}
/* -------------------------
Question generation helpers
-------------------------*/
function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function pickWrongOptions(correct, count=3){

const pool = state.data.streets.map(s=>s.id).filter(id=>id!==correct);
// choose plausible by same initial letter or random
pool.sort(()=>Math.random()-0.5);
return pool.slice(0,count);
}
// proximity: find nearest street by Euclidean distance
function nearestTo(streetId){
const s = getStreet(streetId);
const other = state.data.streets.filter(x=>x.id!==streetId);
other.sort((a,b)=>{
const da = Math.hypot(a.x-s.x,a.y-s.y);
const db = Math.hypot(b.x-s.x,b.y-s.y);
return da-db;
});
return other[0].id;
}
// travessa (link): pick a street that is connected (links)
function linkedPair(){
const s = rand(state.data.streets);
if(s.links.length===0){
// fallback: pick any with link
const t = state.data.streets.find(x=>x.links.length>0);
return [t.id, rand(t.links)];
}
return [s.id, rand(s.links)];
}
// parallel: use parallels dataset if exists, else pick two with similar angle
function parallelPair(){
if(state.data.parallels && state.data.parallels.length){
return rand(state.data.parallels);
} else {
// compute similar angle
let best=null; let minDiff=1e9;
for(let i=0;i<state.data.streets.length;i++){
for(let j=i+1;j<state.data.streets.length;j++){
const a = state.data.streets[i], b=state.data.streets[j];
const d = Math.abs(a.angle-b.angle);
if(d<minDiff){ minDiff=d; best=[a.id,b.id]; }
}
}
return best;
}
}
// next north: pick street with slightly smaller y value (north)

function nextNorth(streetId){
const s = getStreet(streetId);
const north = state.data.streets.filter(t=>t.y < s.y).sort((a,b)=>a.y-b.y);
if(north.length===0) return null;
// pick the nearest north
north.sort((a,b)=>Math.abs(a.y-s.y)-Math.abs(b.y-s.y));
return north[0].id;
}
// crossing: pick a street that shares adjacency (link)
function crossingWith(streetId){
const s = getStreet(streetId);
if(s.links.length>0) return s.links[0];
// fallback find any that crosses by bounding box (approx)
const candidates = state.data.streets.filter(t=>{
return Math.abs(t.x-s.x) < 60 && Math.abs(t.y-s.y) < 60 && t.id!==streetId;
});
return candidates.length? candidates[0].id : null;
}
/* -------------------------
Questions factory
-------------------------*/
function generateQuestion(difficulty){
// types: proximity, travessa, paralelo, nextNorth, crossing, route (insane)
const typesEasy = ['proximity'];
const typesMed = ['proximity','travessa','paralelo'];
const typesHard = ['paralelo','nextNorth','crossing'];
const typesInsane = ['route','crossing','nextNorth'];
let pool = typesEasy;
if(difficulty==='easy') pool = typesEasy;
if(difficulty==='medium') pool = typesMed;
if(difficulty==='hard') pool = typesHard;
if(difficulty==='insane') pool = typesInsane;
const type = rand(pool);
if(type==='proximity'){
const s = rand(state.data.streets);
const correct = nearestTo(s.id);
const wrong = pickWrongOptions(correct);
return {
type:'proximity',
text:`A ${s.id} fica pr√≥xima a qual dessas ruas?`,
answer: correct,
options: shuffle([correct,...wrong]).slice(0,4),
meta: {reference: s.id}
};

} else if(type==='travessa'){
const pair = linkedPair();
const correct = pair[1];
const wrong = pickWrongOptions(correct);
return {
type:'travessa',
text:`A Travessa ${pair[0]} liga quais duas ruas?`,
answer: correct,
options: shuffle([correct,...wrong]).slice(0,4),
meta: {reference: pair[0]}
};
} else if(type==='paralelo'){
const p = parallelPair();
const a = p[0], b = p[1];
const wrong = pickWrongOptions(b);
return {
type:'paralelo',
text:`Qual dessas ruas √© paralela √† ${a}?`,
answer: b,
options: shuffle([b,...wrong]).slice(0,4),
meta: {reference: a}
};
} else if(type==='nextNorth'){
const s = rand(state.data.streets);
const corr = nextNorth(s.id);
if(!corr) return generateQuestion(difficulty); // fallback
const wrong = pickWrongOptions(corr);
return {
type:'north',
text:`Qual rua fica depois da ${s.id} sentido norte?`,
answer: corr,
options: shuffle([corr,...wrong]).slice(0,4),
meta:{reference:s.id}
};
} else if(type==='crossing'){
const s = rand(state.data.streets);
const corr = crossingWith(s.id);
if(!corr) return generateQuestion(difficulty);
const wrong = pickWrongOptions(corr);
return {
type:'crossing',
text:`Qual rua cruza com a ${s.id}?`,
answer:corr,
options: shuffle([corr,...wrong]).slice(0,4),
meta:{reference:s.id}
};
} else if(type==='route'){
// choose two streets and compute shortest path

const ids = state.data.streets.map(s=>s.id);
const a = rand(ids), b = rand(ids.filter(x=>x!==a));
const path = shortestPath(a,b);
if(!path) return generateQuestion(difficulty);
// find next step after a
const next = path[1] || b;
const wrong = pickWrongOptions(next);
return {
type:'route',
text:`Para ir de ${a} at√© ${b}, qual √© a pr√≥xima rua recomendada?`,
answer: next,
options: shuffle([next,...wrong]).slice(0,4),
meta:{start:a,end:b,path}
};
}
}
// simple shuffle
function shuffle(arr){
return arr.slice().sort(()=>Math.random()-0.5);
}
/* -------------------------
Shortest path (BFS on adjacency)
-------------------------*/
function shortestPath(a,b){
const q = [a]; const prev = {}; prev[a]=null;
while(q.length){
const cur=q.shift();
if(cur===b) break;
const node = state.data.streets.find(s=>s.id===cur);
if(!node) continue;
node.links.forEach(n=>{
if(prev[n]===undefined){
prev[n]=cur; q.push(n);
}
});
}
if(prev[b]===undefined) return null;
const path=[]; let x=b;
while(x!==null){ path.push(x); x=prev[x]; }
return path.reverse();
}
/* -------------------------
Game flow
-------------------------*/
document.getElementById('bairroSelect').addEventListener('change', e=>{

state.bairroName = e.target.value;
loadBairro(state.bairroName);
});
document.getElementById('difficulty').addEventListener('change', e=>{
state.difficulty = e.target.value;
});
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('nextBtn').addEventListener('click', nextQuestion);
document.getElementById('saveScore').addEventListener('click', saveScore);
document.getElementById('exportStats').addEventListener('click', exportStats);
document.getElementById('moradorProBtn').addEventListener('click', ()=>{
  alert(`Modo Morador pro. miss√µes desbloqueadas(prot√≥tipo)`);
});
function startGame(){
state.score = 0; state.combo=1; state.streak=0; state.timeLeft=15;
state.stats.plays += 1;
document.getElementById('score').textContent = 0;
document.getElementById('scoreLarge').textContent = 0;
document.getElementById('combo').textContent = 'x1';
document.getElementById('questionPanel').style.display='block';
document.getElementById('startBtn').style.display='none';
document.getElementById('nextBtn').style.display='none';
state.difficulty = document.getElementById('difficulty').value;
nextQuestion();
}
/* Timer */
function startTimer(){
stopTimer();
state.timeLeft = state.difficulty==='insane' ? 12 : state.difficulty==='hard' ? 14 :14;
document.getElementById('timeLeft').textContent = state.timeLeft;
state.timer = setInterval(()=>{
state.timeLeft -= 1;
document.getElementById('timeLeft').textContent = state.timeLeft;
if(state.timeLeft<=0){
stopTimer();
handleAnswer(null,true);
}
},1000);
}
function stopTimer(){ if(state.timer) { clearInterval(state.timer); state.timer=null; } }
function nextQuestion(){
stopTimer();
const q = generateQuestion(state.difficulty);
state.currentQuestion = q;

renderQuestion(q);
startTimer();
}
/* Render question to UI */
function renderQuestion(q){
document.getElementById('questionText').textContent = q.text;
const choices = document.getElementById('choices');
choices.innerHTML='';
q.options.forEach(opt=>{
const b = document.createElement('div'); b.className='choice panel';
b.textContent = opt;
b.onclick = ()=>{ handleAnswer(opt,false); };
choices.appendChild(b);
});
// reset highlights on map
clearHighlights();
}
/* Answer handling */
function handleAnswer(selected, timedOut=false){
stopTimer();
const q = state.currentQuestion;
const correct = q.answer;
const chosen = timedOut ? null : selected;
// update stats
if(chosen === correct){
// correct
state.streak += 1;
state.combo = 1 + Math.floor(state.streak/3); // increase every 3 corrects
const base = 100;
const timeBonus = Math.max(0, Math.floor(state.timeLeft*5));
const pts = base * state.combo + timeBonus;
state.score += pts;
state.stats.correct += 1;
showFeedback(true, q, chosen);
} else {
// wrong
state.streak = 0;
state.combo = 1;
state.stats.wrong += 1;
state.stats.wrongByStreet[ q.meta.reference || q.answer ] =
(state.stats.wrongByStreet[q.meta.reference || q.answer]||0)+1;
showFeedback(false, q, chosen);
}
// update UI
document.getElementById('score').textContent = state.score;
document.getElementById('scoreLarge').textContent = state.score;
document.getElementById('combo').textContent = 'x'+state.combo;
document.getElementById('streak').textContent = state.streak;
document.getElementById('plays').textContent = state.stats.plays;
document.getElementById('totalCorrect').textContent = state.stats.correct;
document.getElementById('totalWrong').textContent = state.stats.wrong;

updateMastery();
// show next
document.getElementById('nextBtn').style.display='inline-block';
}
/* Show visual feedback ‚Äî highlight on map */
function showFeedback(ok, q, chosen){
if(q.type === 'route' && q.meta && q.meta.path){
// highlight path
highlightPath(q.meta.path);
} else {
// highlight correct street
highlightStreet(q.answer, 'good');
if(chosen && chosen !== q.answer) highlightStreet(chosen, 'bad');
// draw connector
const a = getStreet(q.answer);
const b = chosen ? getStreet(chosen) : null;
if(a && b) drawConnector(a,b);
}
// show small popup text
const panel = document.getElementById('questionPanel');
const msg = document.createElement('div');
msg.style.marginTop='8px';
msg.style.fontSize='13px';
msg.textContent = ok ? `Correto! (${state.score} pts)` : `Errado. Resposta correta:
${q.answer}`;
panel.appendChild(msg);
}
/* Highlight helpers */
function highlightStreet(name, kind){
const id = 'line-'+encodeURIComponent(name);
const el = document.getElementById(id);
if(!el) return;
if(kind==='good'){
el.setAttribute('stroke','#16a34a');
el.setAttribute('stroke-width','8');
el.setAttribute('opacity','1');
} else {
el.setAttribute('stroke','#ef4444');
el.setAttribute('stroke-width','8');
el.setAttribute('opacity','1');
}
}
function clearHighlights(){
state.data.streets.forEach(s=>{
const id='line-'+encodeURIComponent(s.id);
const el = document.getElementById(id);

if(el){
el.setAttribute('stroke','rgba(255,255,255,0.12)');
el.setAttribute('stroke-width','6');
el.setAttribute('opacity','1');
}
});
// remove connector lines
const svg = document.getElementById('mapSvg');
const cons = svg.querySelectorAll('.connectorLine');
cons.forEach(c=>c.remove());
// remove path highlights
const pLines = svg.querySelectorAll('.pathLine');
pLines.forEach(pl=>pl.remove());
// remove extra message nodes under questionPanel
const panel = document.getElementById('questionPanel');
const extras = panel.querySelectorAll('div'); // careful
// leave first two (question and choices container)
// remove later appended messages (we appended last)
if(extras.length>2){
// keep first 2; remove rest
for(let i=extras.length-1;i>=2;i--){
extras[i].remove();
}
}
}
function drawConnector(a,b){
const svg = document.getElementById('mapSvg');
const line = document.createElementNS('http://www.w3.org/2000/svg','line');
line.setAttribute('x1', a.x); line.setAttribute('y1', a.y);
line.setAttribute('x2', b.x); line.setAttribute('y2', b.y);
line.setAttribute('stroke','rgba(255,255,255,0.6)');
line.setAttribute('stroke-width','2');
line.setAttribute('class','connectorLine');
svg.appendChild(line);
}
function highlightPath(path){
const svg = document.getElementById('mapSvg');
for(let i=0;i<path.length-1;i++){
const a = getStreet(path[i]), b=getStreet(path[i+1]);
const line = document.createElementNS('http://www.w3.org/2000/svg','line');
line.setAttribute('x1', a.x); line.setAttribute('y1', a.y);
line.setAttribute('x2', b.x); line.setAttribute('y2', b.y);
line.setAttribute('stroke','#ffd166');
line.setAttribute('stroke-width','6');
line.setAttribute('class','pathLine');
svg.appendChild(line);

}
}
/* -------------------------
Mastery and rankings (localStorage)
-------------------------*/
function updateMastery(){
// mastery = percent of streets with zero wrong answers? Simplified:
const total = state.data.streets.length;
const wrongCounts = Object.values(state.stats.wrongByStreet).reduce((a,b)=>a+b,0);
// estimate: mastery increases with correct answers; rough formula:
const mastery = Math.min(100, Math.round( (state.stats.correct /
Math.max(1,(state.stats.correct+state.stats.wrong)) ) * 100 ));
document.getElementById('masteryPct').textContent = mastery+'%';
document.getElementById('progress').value = mastery;
// enable Morador Pro if >=80
const btn = document.getElementById('moradorProBtn');
if(mastery>=80){ btn.disabled=false;
document.getElementById('badgeMode').textContent='Modo: Morador Pro dispon√≠vel'; }
else { btn.disabled=true; document.getElementById('badgeMode').textContent='Modo: Quiz'; }
}
/* Ranking simple local */
function saveScore(){
const name = document.getElementById('playerName').value.trim() || 'Anon';
const list = JSON.parse(localStorage.getItem('mm_bairro_scores')||'[]');
list.push({name,score:state.score,date:new Date().toISOString()});
list.sort((a,b)=>b.score-a.score);
localStorage.setItem('mm_bairro_scores', JSON.stringify(list.slice(0,50)));
renderLeaderboard();
}
/* Render leaderboard */
function renderLeaderboard(){
const list = JSON.parse(localStorage.getItem('mm_bairro_scores')||'[]');
const ol = document.getElementById('leaderboardList'); ol.innerHTML='';
list.slice(0,10).forEach(it=>{
const li = document.createElement('li');
li.textContent = `${it.name} ‚Äî ${it.score} pts`;
ol.appendChild(li);
});
}
/* Export stats (JSON) */
function exportStats(){
const payload = {
bairro: state.bairroName,
stats: state.stats,

score: state.score
};
const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
const url = URL.createObjectURL(blob);
const a = document.createElement('a'); a.href=url; a.download='mm_stats.json'; a.click();
URL.revokeObjectURL(url);
}
/* -------------------------
Utility: get best wrong streets list UI
-------------------------*/
function updateStatsUI(){
const errors = state.stats.wrongByStreet;
const list = Object.keys(errors).map(k=>({k,v:errors[k]})).sort((a,b)=>b.v-a.v);
document.getElementById('errorList').textContent = list.length? list.map(x=>x.k+`
(${x.v})`).join(', ') : 'nenhum';
}
/* -------------------------
Init
-------------------------*/
loadBairro(state.bairroName);
renderLeaderboard();
/* Provide a quick demo start if user wants */
console.log('Prot√≥tipo "Mapa Mental do Bairro" carregado. Clique em Iniciar para jogar.');
</script>
</body>
</html>